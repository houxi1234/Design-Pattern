# Design-Pattern
设计模式回顾

##工厂模式
#####简单工厂
######
#####工厂方法
######
#####抽象工厂
######

##单例模式
#####懒加载
######
#####饥饿
######
#####注册式
######

##代理模式
#####静态代理
#####动态代理
######JDKProxy实现原理：通过字节码重组实现,基于接口
######1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取
######2、JDK Proxy类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口
######3、动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）
######4、编译新生成的Java代码.class
######5、再重新加载到JVM中运行
######CglibProxy实现原理：基于继承
##策略模式
######消灭了if else、switch
##模版模式
######有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式
##委派模式
#####有点类似代理模式和策略模式
######类B和类A是两个互相没有任何关系的类，但是B具有和A一模一样的方法和属性；并且调用B中的方法/属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介，第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种功能，又能够很好的将A保护起来。
##适配器模式：常用于代码维护，向下兼容
#####类适配器模式：通过继承实现
######
#####对象适配器模式：通过类的组合实现
######
#####接口适配器模式：通过抽象类来实现  
######当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便    