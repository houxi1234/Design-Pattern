# Design-Pattern
设计模式回顾

##工厂模式
#####简单工厂
#####工厂方法
#####抽象工厂

##单例模式
#####懒加载
#####饥饿
#####注册式

##代理模式
#####静态代理
#####动态代理
######JDKProxy实现原理：通过字节码重组实现,基于接口
######1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取
######2、JDK Proxy类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口
######3、动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）
######4、编译新生成的Java代码.class
######5、再重新加载到JVM中运行
######CglibProxy实现原理：基于继承
##策略模式
######消灭了if else、switch
##模版模式
######有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式
##委派模式
#####有点类似代理模式和策略模式
######类B和类A是两个互相没有任何关系的类，但是B具有和A一模一样的方法和属性；并且调用B中的方法/属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介，第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种功能，又能够很好的将A保护起来。
      
      
